## 谈谈 事件轮询机制
​              事件循环模型/事件轮询机制（Event Loop）：
                1.代码分类：
                    - 初始化代码（同步代码）：for循环等、绑定事件、设置定时器、发送ajax请求
                    - 回调执行代码（异步代码）：事件回调函数、定时器回调函数、ajax请求回调函数
                2.代码执行顺序：
                    - 先执行同步代码
                    - 再执行异步代码
                3.事件模型的两个内容
                    - 浏览器的事件管理模块（DOM事件管理模块、AJAX管理模块、定时器管理模块）
                    - 回调队列
                4.事件轮询
                    - 执行初始化代码，并把异步回调函数交给对应的事件管理模块
                    - 事件发生的时候，事件管理模块会把对应的函数和数据交给 回调队列
                    - 初始化代码执行完成之后，会遍历回调队列中的函数并执行

## 谈谈js事件机制
概念：
            多个节点对象对同一个事件的响应顺序，被称作为事件流
            W3C事件流：
                1.执行捕获阶段：网景浏览器提出，事件由最不精确的对象（document）依次执行到最精确的目标元素（target）
                2.执行目标事件
                3.执行冒泡阶段：IE浏览器提出，事件由最精确的目标元素（target） 依次执行到 最不精确的对象（document）
                4.事件根据自身是冒泡还是捕获，决定自身在哪一个阶段执行
## this的指向
  this是什么？
                - 一个关键字，一个引用变量
                - this在函数中可以直接使用
                - this指向其所在函数的调用者，如果没有则指向window
                - this在函数执行的时候才确定指向
            this的指向和函数的调用方式相关：
                - 函数默认调用（独立函数调用）
                    - 指向window
                - 上下文对象调用
                    - 指向上下文对象
                    - 可能会出现隐式丢失现象（注意隐式丢失以后，this的指向）
                - 实例化调用
                    - this指向实例化对象
                - call apply bind 强制绑定
                    指向call、apply、bind的第一个参数
            怎么确定this指向呢？
                1.先看有没有强制绑定
                2.再看是不是实例化调用
                3.看是否有上下文对象调用
                4.默认绑定
## 谈谈props
1.使用组件标签时
<MyComponent name='tom' :age='3' :setName='setName'></MyComponent >
<my-component name='tom' :age='3' :set-name='setName'></my-component>
2.定义MyComponent时
1)在组件内声明所有的props
2)方式一: 只指定名称
props: ['name', 'age', 'setName']
3)方式二: 指定名称和类型
	props: {
	  name: String,
	  age: Number,
	  setNmae: Function
	}
4)方式三: 指定名称/类型/必要性/默认值
	props: {
	   name: {type: String, required: true, default:xxx, validator: function() {}},
	}
总结：
1)	此方式用于父组件与子组件之间传递数据
2)	所有标签属性都会成为组件对象的属性, 模板页面可以直接引用
3)问题: 
a.如果需要向非子后代传递数据必须多层逐层传递
b.兄弟组件间也不能直接props通信, 必须借助父组件才可以